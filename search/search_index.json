{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introducing Squirrels A Python API framework for generating dynamic queries for analytics. Squirrels is an API framework for creating APIs that generate sql queries & dataframes dynamically from query parameters. Start by reading the Getting Started page, then check the Overview page for understanding the framework. Why the name \"squirrels\"? \"Squirrels\" stands for \" S tructured QU ery I nterface with R ealtime R endering and E laborate L anguage S ynchronization\". The current \"languages\" include SQL and Python. It's also called \"squirrels\" for the following reasons: \"SQURL\" was also considered as a name for the framework, which is short for \"SQL URL\". This sounds like \"squirrel\" Following the theme of using animal names (plural form) for useful python packages (like \"pandas\")","title":"Home"},{"location":"#introducing-squirrels","text":"A Python API framework for generating dynamic queries for analytics. Squirrels is an API framework for creating APIs that generate sql queries & dataframes dynamically from query parameters. Start by reading the Getting Started page, then check the Overview page for understanding the framework.","title":"Introducing Squirrels"},{"location":"#why-the-name-squirrels","text":"\"Squirrels\" stands for \" S tructured QU ery I nterface with R ealtime R endering and E laborate L anguage S ynchronization\". The current \"languages\" include SQL and Python. It's also called \"squirrels\" for the following reasons: \"SQURL\" was also considered as a name for the framework, which is short for \"SQL URL\". This sounds like \"squirrel\" Following the theme of using animal names (plural form) for useful python packages (like \"pandas\")","title":"Why the name \"squirrels\"?"},{"location":"getting-started/","text":"Getting Started with Squirrels An introductory tutorial! Installation First, in the folder for your squirrels project, create the virtual environment. For example, you can use pipenv (install with pip install pipenv ) to create the virtual environment, and install the squirrels library in one command: pipenv install squirrels Activate the virtual environment with: pipenv shell and deactivate with exit . Initialize a New Project You can initialize the project files using: squirrels init --core --sample-db seattle-weather For the purpose of this tutorial, we are using the --sample-db option to create a sample database to use. All the core files are also created using the --core option. Note Without using any CLI options (i.e., just squirrels init ), a set of prompts will be provided instead for the file(s) you need, and the core files would be created by default. However, the prompts go away by specifying any CLI options, and the core files are not created by default if the --core option is not included. Once the command is executed, all core files are created. This includes: .gitignore , requirements.txt , and squirrels.yaml at the project root parameters.py and database_view.sql.j2 in the datasets/sample_dataset subfolder seattle_weather.db sqlite database in the database folder For more details, see docs for the init CLI . Provide the Database Connection Next, create a squirrels database profile with a specified profile name of your choice. For the rest of the tutorial, we will assume the profile name is myprofile . squirrels set-profile myprofile --values sqlite /./database/seattle_weather.db \"\" \"\" The --values option let you specify the sql dialect/driver, database url, username, and password in the command line all at once instead of using the set of prompts. Note It is better practice to use an absolute path in the database url for the sqlite database. We are using a relative path to seattle_weather.db here for simplicity. In the squirrels.yaml file, set the db_profile to myprofile . For more details on database profiles, see docs for the set-profile CLI . Configure a Dataset In the squirrels.yaml file, set the product property under project_variables to seattle_weather . Replace the sample_dataset field (under datasets ) with weather_by_time . Specify the following values under the weather_by_time field: Set label to Weather by Time of Year Set name (under database_views ) to weather_by_time Set file (under database_views ) to weather_by_time.sql.j2 Set final_view to final_view.sql.j2 At this point in time, your squirrels.yaml file should look something like this: project_variables: product: seattle_weather major_version: '0' minor_version: '1' modules: [] db_profile: myprofile base_path: \"/{{product}}/v{{major_version}}\" datasets: weather_by_time: label: Weather by Time of Year database_views: - name: weather_by_time file: weather_by_time.sql.j2 final_view: weather_by_time settings: {} Rename the following files/folders to reflect the changes you made in the squirrels.yaml file. Rename datasets/sample_dataset to datasets/weather_by_time Rename datasets/weather_by_time/database_view1.sql.j2 to datasets/weather_by_time/weather_by_time.sql.j2 For more details on the squirrels.yaml file, see the docs for squirrels.yaml . Create the Parameters In the datasets/weather_by_time/ folder, there's a parameters.py file to specify the parameters for the weather_by_time dataset. Replace the contents of the parameters.py file with the following. from typing import Callable import squirrels as sq class GroupByOption(sq.ParameterOption): def __init__(self, id, label, dim_col, order_by_col = None): super().__init__(id, label) self.dim_col = dim_col self.order_by_col = order_by_col if order_by_col is not None else dim_col group_by_options = [ GroupByOption('0', 'Year', 'year'), GroupByOption('1', 'Quarter', 'quarter'), GroupByOption('2', 'Month', 'month_name', 'month_order'), GroupByOption('3', 'Day of Year', 'day_of_year'), GroupByOption('4', 'Condition', 'condition') ] def main() -> Dict[str, sq.Parameter]: return { 'group_by': sq.SingleSelectParameter('Group By', group_by_options), } Classes like ParameterOption , Parameter , and SingleSelectParameter are provided by the squirrels framework. In the code above, we extend from the existing ParameterOption class to create our own class with additional attributes. We will be able to use these attributes in the sql query templates we define later. The parameters.py file must specify a main() function that returns a dictionary of parameter names (as keys) to parameter objects (as value). In the code above, we specified one single-select parameter called group_by which will affect the dimension column used for aggregating in the sql query. For more details on the available classes for parameter configurations, see docs for parameters.py . Create the Dynamic SQL Query In the datasets/weather_by_time/ folder, replace the contents of the weather_by_time.sql.j2 file with the following. {% set selected_group_by = prms('group_by').get_selected() -%} {% set dim_col = selected_group_by.dim_col -%} {% set order_col = selected_group_by.order_by_col -%} SELECT {{ dim_col }} , avg(temp_max) as temperature_high_C , avg(temp_min) as temperature_low_C , avg(precipitation) as precipitation_inches , avg(wind) as wind_mph FROM weather GROUP BY {{ dim_col }}, {{ order_col }} ORDER BY {{ order_col }} The lines written like {% set ... -%} uses Jinja2 syntax to create variables for the templated sql to use. The prms function is available to retrieve a Parameter object, and for SingleSelectParameter's, the .get_selected() method is available to retrieve the selected ParameterOption, which we extended as a GroupByOption. Thus, the dim_col and order_by_col attributes are available on the GroupByOption. The database view file can also be a python file. For more details, see the docs for database views . Note that this example only uses one \"database view\", and the \"final view\" does not apply any further transformations. For more complex use cases, you can also write Jinja2 templated sql or python files for the final view as well to process on the API server from the results of one or more database views. For more details, see the docs for final view . In addition, this framework also lets you define the dim_col and order_col variables through python instead of through the Jinja template. For more details, see the docs for context.py . Test the Generated Output You can test the output of the generated SQL query and parameters response for the default parameter selections of the weather_by_time dataset by running: squirrels test weather_by_time This creates a outputs/weather_by_time subfolder with the generated SQL query without running it yet. Confirm all outputs look as expected. You can also run the following to generate all database views and final view results as csv files. squirrels test weather_by_time --runquery You can also test on non-default parameter selections. For more details, see docs for the test CLI . Run the API Server Run the following CLI command to activate the API server in \"debug mode\": squirrels run --debug You should now be able to access the following APIs. http://localhost:8000/squirrels0/seattle-weather/v0 Catalog of the parameters and results APIs for each dataset http://localhost:8000/squirrels0/seattle-weather/v0/weather-by-time/parameters All the parameters information for the dataset http://localhost:8000/squirrels0/seattle-weather/v0/weather-by-time The results of the dataset using the default value for each parameter For a simple UI to test the API interactions, go to http://localhost:8000/ from your browser. For more details, see docs for the run CLI .","title":"Getting Started"},{"location":"getting-started/#getting-started-with-squirrels","text":"An introductory tutorial!","title":"Getting Started with Squirrels"},{"location":"getting-started/#installation","text":"First, in the folder for your squirrels project, create the virtual environment. For example, you can use pipenv (install with pip install pipenv ) to create the virtual environment, and install the squirrels library in one command: pipenv install squirrels Activate the virtual environment with: pipenv shell and deactivate with exit .","title":"Installation"},{"location":"getting-started/#initialize-a-new-project","text":"You can initialize the project files using: squirrels init --core --sample-db seattle-weather For the purpose of this tutorial, we are using the --sample-db option to create a sample database to use. All the core files are also created using the --core option. Note Without using any CLI options (i.e., just squirrels init ), a set of prompts will be provided instead for the file(s) you need, and the core files would be created by default. However, the prompts go away by specifying any CLI options, and the core files are not created by default if the --core option is not included. Once the command is executed, all core files are created. This includes: .gitignore , requirements.txt , and squirrels.yaml at the project root parameters.py and database_view.sql.j2 in the datasets/sample_dataset subfolder seattle_weather.db sqlite database in the database folder For more details, see docs for the init CLI .","title":"Initialize a New Project"},{"location":"getting-started/#provide-the-database-connection","text":"Next, create a squirrels database profile with a specified profile name of your choice. For the rest of the tutorial, we will assume the profile name is myprofile . squirrels set-profile myprofile --values sqlite /./database/seattle_weather.db \"\" \"\" The --values option let you specify the sql dialect/driver, database url, username, and password in the command line all at once instead of using the set of prompts. Note It is better practice to use an absolute path in the database url for the sqlite database. We are using a relative path to seattle_weather.db here for simplicity. In the squirrels.yaml file, set the db_profile to myprofile . For more details on database profiles, see docs for the set-profile CLI .","title":"Provide the Database Connection"},{"location":"getting-started/#configure-a-dataset","text":"In the squirrels.yaml file, set the product property under project_variables to seattle_weather . Replace the sample_dataset field (under datasets ) with weather_by_time . Specify the following values under the weather_by_time field: Set label to Weather by Time of Year Set name (under database_views ) to weather_by_time Set file (under database_views ) to weather_by_time.sql.j2 Set final_view to final_view.sql.j2 At this point in time, your squirrels.yaml file should look something like this: project_variables: product: seattle_weather major_version: '0' minor_version: '1' modules: [] db_profile: myprofile base_path: \"/{{product}}/v{{major_version}}\" datasets: weather_by_time: label: Weather by Time of Year database_views: - name: weather_by_time file: weather_by_time.sql.j2 final_view: weather_by_time settings: {} Rename the following files/folders to reflect the changes you made in the squirrels.yaml file. Rename datasets/sample_dataset to datasets/weather_by_time Rename datasets/weather_by_time/database_view1.sql.j2 to datasets/weather_by_time/weather_by_time.sql.j2 For more details on the squirrels.yaml file, see the docs for squirrels.yaml .","title":"Configure a Dataset"},{"location":"getting-started/#create-the-parameters","text":"In the datasets/weather_by_time/ folder, there's a parameters.py file to specify the parameters for the weather_by_time dataset. Replace the contents of the parameters.py file with the following. from typing import Callable import squirrels as sq class GroupByOption(sq.ParameterOption): def __init__(self, id, label, dim_col, order_by_col = None): super().__init__(id, label) self.dim_col = dim_col self.order_by_col = order_by_col if order_by_col is not None else dim_col group_by_options = [ GroupByOption('0', 'Year', 'year'), GroupByOption('1', 'Quarter', 'quarter'), GroupByOption('2', 'Month', 'month_name', 'month_order'), GroupByOption('3', 'Day of Year', 'day_of_year'), GroupByOption('4', 'Condition', 'condition') ] def main() -> Dict[str, sq.Parameter]: return { 'group_by': sq.SingleSelectParameter('Group By', group_by_options), } Classes like ParameterOption , Parameter , and SingleSelectParameter are provided by the squirrels framework. In the code above, we extend from the existing ParameterOption class to create our own class with additional attributes. We will be able to use these attributes in the sql query templates we define later. The parameters.py file must specify a main() function that returns a dictionary of parameter names (as keys) to parameter objects (as value). In the code above, we specified one single-select parameter called group_by which will affect the dimension column used for aggregating in the sql query. For more details on the available classes for parameter configurations, see docs for parameters.py .","title":"Create the Parameters"},{"location":"getting-started/#create-the-dynamic-sql-query","text":"In the datasets/weather_by_time/ folder, replace the contents of the weather_by_time.sql.j2 file with the following. {% set selected_group_by = prms('group_by').get_selected() -%} {% set dim_col = selected_group_by.dim_col -%} {% set order_col = selected_group_by.order_by_col -%} SELECT {{ dim_col }} , avg(temp_max) as temperature_high_C , avg(temp_min) as temperature_low_C , avg(precipitation) as precipitation_inches , avg(wind) as wind_mph FROM weather GROUP BY {{ dim_col }}, {{ order_col }} ORDER BY {{ order_col }} The lines written like {% set ... -%} uses Jinja2 syntax to create variables for the templated sql to use. The prms function is available to retrieve a Parameter object, and for SingleSelectParameter's, the .get_selected() method is available to retrieve the selected ParameterOption, which we extended as a GroupByOption. Thus, the dim_col and order_by_col attributes are available on the GroupByOption. The database view file can also be a python file. For more details, see the docs for database views . Note that this example only uses one \"database view\", and the \"final view\" does not apply any further transformations. For more complex use cases, you can also write Jinja2 templated sql or python files for the final view as well to process on the API server from the results of one or more database views. For more details, see the docs for final view . In addition, this framework also lets you define the dim_col and order_col variables through python instead of through the Jinja template. For more details, see the docs for context.py .","title":"Create the Dynamic SQL Query"},{"location":"getting-started/#test-the-generated-output","text":"You can test the output of the generated SQL query and parameters response for the default parameter selections of the weather_by_time dataset by running: squirrels test weather_by_time This creates a outputs/weather_by_time subfolder with the generated SQL query without running it yet. Confirm all outputs look as expected. You can also run the following to generate all database views and final view results as csv files. squirrels test weather_by_time --runquery You can also test on non-default parameter selections. For more details, see docs for the test CLI .","title":"Test the Generated Output"},{"location":"getting-started/#run-the-api-server","text":"Run the following CLI command to activate the API server in \"debug mode\": squirrels run --debug You should now be able to access the following APIs. http://localhost:8000/squirrels0/seattle-weather/v0 Catalog of the parameters and results APIs for each dataset http://localhost:8000/squirrels0/seattle-weather/v0/weather-by-time/parameters All the parameters information for the dataset http://localhost:8000/squirrels0/seattle-weather/v0/weather-by-time The results of the dataset using the default value for each parameter For a simple UI to test the API interactions, go to http://localhost:8000/ from your browser. For more details, see docs for the run CLI .","title":"Run the API Server"},{"location":"overview/","text":"Overview Understanding the why's and how's of the squirrels framework Purpose Imagine you're a BI or data analyst for a bank, and you have a record of data for every time the bank provided a loan. Every loan record would have columns for the date, the loan amount, the interest rate, the credit score, the location, and dozens of other attributes. The business teams may have questions like the total loan amount per week for the last 12 weeks or the average interest rate offered by credit score tier. You build a sql query to answer one of these questions, and since the number of records grow over time, you save the sql query such that the same question can be answered again and again for subsequent weeks. This is great at all, but unfortunately, the amount of hours in effort is directly proportional to the number of business questions that need to be answered. It would be better if the sql query can take parameters to be dynamically generated with various values for columns to group by, metrics to show, filters to apply, etc. And this framework allows you to do just that! Parameter types include (but not limited to) single-select, multi-select, dates, and numeric values. Certain BI applications, such as Tableau, provide ways to specify parameters and create dynamic data analytics based on selected parameter values. However, the logic behind how the parameters affect the analytical queries is isolated in Tableau. Ideally, the logic should be reusable by multiple applications, even by applications you can create yourself! This can be done if there is a REST API that performs the calculations by using the query parameters for parameter values and using the response body for the tabular results. Thankfully, the squirrels framework makes it easy to create these APIs without having to be an expert in developing REST APIs from scratch! Keep in mind that the use case extends beyond just loan events or financial data. Any sort of data analytics can make use of this framework! For examples, it can used to create APIs for analyzing weather metrics by time period/location, analyzing demographics of segments of population, or analyzing revenue/expenses for various segments of a business. Basic Concepts Similar to how web frameworks render templated HTML by retrieving records from a database with (mostly) static queries, the squirrels framework render templated (complex) SQL queries from query parameters to create tabular results that can be sent back as JSON (or any format that can represent structured data). The templating language for the SQL queries is Jinja . All sql queries that can be represented by the same templated SQL query is known as a \"dataset\". First, an application can get the name and resource paths of all the datasets of a squirrels project by using a GET request on the base resource path for the project: /project/basepath Suppose we have a dataset that can be retrieved from the following API resource path using a GET request: /project/basepath/dataset This dataset may have parameters that can be provided through query parameters. The application can retrieve all the parameter details for the dataset by adding a /parameters suffix to the dataset's resource path with a GET request as such: /project/basepath/parameters Certain parameters may cascade. For instance, if there are parameter for country and city filters, the options for city can be limited by the selected value for country . Thus, the parameters' path can use the same query parameters as the dataset's path to deal with the cascading effects. For both paths, the default value(s) for the parameter is used if the parameter value is not specified. Parameter details (such as parameter options) can either be purely specified in the squirrels project's dataset folder (in the parameters.py file), or retrieved from lookup tables in the database. For the first time that a datatset API is triggered on a server, parameters get converted into objects in memory, which may include queries to the database. This applies to both the parameters' and dataset paths. After the first call to one, subsequent calls to either paths would have these objects cached in memory and don't require further database queries to retrieve parameter details. Next, a copy of the cached parameter objects are created, and the parameter values (taken from the query parameters) are set on these parameter objects. A copy must be made such that concurrent API requests don't end up overriding parameters selections on each other. The parameter object collections are cached based on the query parameters provided such that two parameters API requests with the same query parameters don't have to re-apply the copying and cascading effects. Once the parameter selections are finalized, \"context variables\" are constructed. These are python variables that can be created at runtime after parameter selections are set in the context.py file. For example, a context variable can be a comma-delimited string value of the selected options of a multi-select parameter. The context.py is actually optional, and no context variables are set when this file doesn't exist. Then, one or more templated sql queries are rendered to run against one or more database(s)/data warehouse(s). These templated can access python variables for parameter objects, context variables, or \"project variables\". Project variables are fixed values set for the squirrels project such as \"version\". The rendered sql queries and results are known as \"database views\". Alternatively, instead of templated sql, database views can also be a python function that returns a pandas dataframe. See the database views docs for more information. Finally, there is a \"final view\" that runs in the API server's memory to combine all the database views together to create the final result for the dataset. The final view can be a templated sql query as well. The API server is generally easier to horizontally scale compared to databases. This works by loading all the results of the database views as tables in an in-memory sqlite database and using the final view query to process the tables. The final view can also be a python function that takes all the database views as inputs (as pandas dataframes), and returns one pandas dataframe as a result. Or in the simplest case, the final view can just be the name of one of the database views. The final results are cached based on the query parameters provided such that two parameters API requests don't have to do the same work. See the final view docs for more information. The diagram below visualizes this workflow:","title":"Overview"},{"location":"overview/#overview","text":"Understanding the why's and how's of the squirrels framework","title":"Overview"},{"location":"overview/#purpose","text":"Imagine you're a BI or data analyst for a bank, and you have a record of data for every time the bank provided a loan. Every loan record would have columns for the date, the loan amount, the interest rate, the credit score, the location, and dozens of other attributes. The business teams may have questions like the total loan amount per week for the last 12 weeks or the average interest rate offered by credit score tier. You build a sql query to answer one of these questions, and since the number of records grow over time, you save the sql query such that the same question can be answered again and again for subsequent weeks. This is great at all, but unfortunately, the amount of hours in effort is directly proportional to the number of business questions that need to be answered. It would be better if the sql query can take parameters to be dynamically generated with various values for columns to group by, metrics to show, filters to apply, etc. And this framework allows you to do just that! Parameter types include (but not limited to) single-select, multi-select, dates, and numeric values. Certain BI applications, such as Tableau, provide ways to specify parameters and create dynamic data analytics based on selected parameter values. However, the logic behind how the parameters affect the analytical queries is isolated in Tableau. Ideally, the logic should be reusable by multiple applications, even by applications you can create yourself! This can be done if there is a REST API that performs the calculations by using the query parameters for parameter values and using the response body for the tabular results. Thankfully, the squirrels framework makes it easy to create these APIs without having to be an expert in developing REST APIs from scratch! Keep in mind that the use case extends beyond just loan events or financial data. Any sort of data analytics can make use of this framework! For examples, it can used to create APIs for analyzing weather metrics by time period/location, analyzing demographics of segments of population, or analyzing revenue/expenses for various segments of a business.","title":"Purpose"},{"location":"overview/#basic-concepts","text":"Similar to how web frameworks render templated HTML by retrieving records from a database with (mostly) static queries, the squirrels framework render templated (complex) SQL queries from query parameters to create tabular results that can be sent back as JSON (or any format that can represent structured data). The templating language for the SQL queries is Jinja . All sql queries that can be represented by the same templated SQL query is known as a \"dataset\". First, an application can get the name and resource paths of all the datasets of a squirrels project by using a GET request on the base resource path for the project: /project/basepath Suppose we have a dataset that can be retrieved from the following API resource path using a GET request: /project/basepath/dataset This dataset may have parameters that can be provided through query parameters. The application can retrieve all the parameter details for the dataset by adding a /parameters suffix to the dataset's resource path with a GET request as such: /project/basepath/parameters Certain parameters may cascade. For instance, if there are parameter for country and city filters, the options for city can be limited by the selected value for country . Thus, the parameters' path can use the same query parameters as the dataset's path to deal with the cascading effects. For both paths, the default value(s) for the parameter is used if the parameter value is not specified. Parameter details (such as parameter options) can either be purely specified in the squirrels project's dataset folder (in the parameters.py file), or retrieved from lookup tables in the database. For the first time that a datatset API is triggered on a server, parameters get converted into objects in memory, which may include queries to the database. This applies to both the parameters' and dataset paths. After the first call to one, subsequent calls to either paths would have these objects cached in memory and don't require further database queries to retrieve parameter details. Next, a copy of the cached parameter objects are created, and the parameter values (taken from the query parameters) are set on these parameter objects. A copy must be made such that concurrent API requests don't end up overriding parameters selections on each other. The parameter object collections are cached based on the query parameters provided such that two parameters API requests with the same query parameters don't have to re-apply the copying and cascading effects. Once the parameter selections are finalized, \"context variables\" are constructed. These are python variables that can be created at runtime after parameter selections are set in the context.py file. For example, a context variable can be a comma-delimited string value of the selected options of a multi-select parameter. The context.py is actually optional, and no context variables are set when this file doesn't exist. Then, one or more templated sql queries are rendered to run against one or more database(s)/data warehouse(s). These templated can access python variables for parameter objects, context variables, or \"project variables\". Project variables are fixed values set for the squirrels project such as \"version\". The rendered sql queries and results are known as \"database views\". Alternatively, instead of templated sql, database views can also be a python function that returns a pandas dataframe. See the database views docs for more information. Finally, there is a \"final view\" that runs in the API server's memory to combine all the database views together to create the final result for the dataset. The final view can be a templated sql query as well. The API server is generally easier to horizontally scale compared to databases. This works by loading all the results of the database views as tables in an in-memory sqlite database and using the final view query to process the tables. The final view can also be a python function that takes all the database views as inputs (as pandas dataframes), and returns one pandas dataframe as a result. Or in the simplest case, the final view can just be the name of one of the database views. The final results are cached based on the query parameters provided such that two parameters API requests don't have to do the same work. See the final view docs for more information. The diagram below visualizes this workflow:","title":"Basic Concepts"},{"location":"cli-guide/delete-profile/","text":"","title":"delete-profile"},{"location":"cli-guide/get-all-profiles/","text":"","title":"get-all-profiles"},{"location":"cli-guide/init/","text":"","title":"init"},{"location":"cli-guide/load-modules/","text":"","title":"load-modules"},{"location":"cli-guide/run/","text":"Squirrels Run Command","title":"run"},{"location":"cli-guide/run/#squirrels-run-command","text":"","title":"Squirrels Run Command"},{"location":"cli-guide/set-profile/","text":"","title":"set-profile"},{"location":"cli-guide/test/","text":"","title":"test"},{"location":"user-guide/context/","text":"","title":"context.py"},{"location":"user-guide/database-views/","text":"","title":"database views"},{"location":"user-guide/final-view/","text":"","title":"final view"},{"location":"user-guide/parameters/","text":"Parameter Configurations","title":"parameters.py"},{"location":"user-guide/parameters/#parameter-configurations","text":"","title":"Parameter Configurations"},{"location":"user-guide/sample-lu-data/","text":"","title":"sample_lu_data.xlsx"},{"location":"user-guide/selections/","text":"","title":"selections.cfg"},{"location":"user-guide/squirrels-manifest/","text":"Squirrels Manifest File","title":"squirrels.yaml"},{"location":"user-guide/squirrels-manifest/#squirrels-manifest-file","text":"","title":"Squirrels Manifest File"}]}